name: Deploy to Hostinger
'on':
  push:
    branches:
      - main
  workflow_dispatch: null
env:
  NODE_VERSION: '18'
  DEPLOYMENT_TIMEOUT: 300
jobs:
  deploy:
    runs-on: ubuntu-latest
    timeout-minutes: 30
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '${{ env.NODE_VERSION }}'
          cache: npm
      - name: Validate secrets
        run: |
          echo "Validating required secrets..."
          required_secrets=(
            "HOSTINGER_HOST"
            "HOSTINGER_USER" 
            "HOSTINGER_SSH_KEY"
            "DB_PASSWORD"
            "JWT_SECRET"
            "NEXT_PUBLIC_APP_URL"
          )

          missing_secrets=()
          for secret in "${required_secrets[@]}"; do
            if [ -z "${!secret}" ]; then
              missing_secrets+=("$secret")
            fi
          done

          if [ ${#missing_secrets[@]} -ne 0 ]; then
            echo "❌ Missing required secrets: ${missing_secrets[*]}"
            exit 1
          fi

          echo "✅ All required secrets are present"
        env:
          HOSTINGER_HOST: '${{ secrets.HOSTINGER_HOST }}'
          HOSTINGER_USER: '${{ secrets.HOSTINGER_USER }}'
          HOSTINGER_SSH_KEY: '${{ secrets.HOSTINGER_SSH_KEY }}'
          DB_PASSWORD: '${{ secrets.DB_PASSWORD }}'
          JWT_SECRET: '${{ secrets.JWT_SECRET }}'
          NEXT_PUBLIC_APP_URL: '${{ secrets.NEXT_PUBLIC_APP_URL }}'
      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.HOSTINGER_SSH_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa

          # Add host key verification with retry
          for i in {1..3}; do
            if ssh-keyscan -H -p 65002 ${{ secrets.HOSTINGER_HOST }} >> ~/.ssh/known_hosts 2>/dev/null; then
              echo "✅ Host key added successfully"
              break
            else
              echo "⚠️ Attempt $i failed, retrying..."
              sleep 5
            fi
          done
      - name: Test SSH connection
        run: >
          ssh -o ConnectTimeout=30 -o ServerAliveInterval=10 -p 65002 ${{
          secrets.HOSTINGER_USER }}@${{ secrets.HOSTINGER_HOST }} "echo 'SSH
          connection successful'"
      - name: Install dependencies and build
        run: "echo \"\U0001F4E6 Installing dependencies...\"\nnpm ci --prefer-offline --no-audit\n\necho \"\U0001F3D7️ Building application...\"\nnpm run build\n\necho \"\U0001F50D Running linting...\"\nnpm run lint || echo \"⚠️ Linting completed with warnings\"\n\necho \"\U0001F527 Type checking...\"\nnpm run type-check || echo \"⚠️ Type checking completed with warnings\"\n"
      - name: Create deployment archive
        run: "echo \"\U0001F4E6 Creating deployment archive...\"\n\n# Create archive with specific inclusions to avoid issues\ntar -czf nextdash-deployment.tar.gz \\\n  --exclude='node_modules' \\\n  --exclude='.git' \\\n  --exclude='.next/cache' \\\n  --exclude='*.log' \\\n  --exclude='.env*' \\\n  --exclude='coverage' \\\n  --exclude='*.test.*' \\\n  --exclude='__tests__' \\\n  --exclude='.github' \\\n  --exclude='README.md' \\\n  --exclude='*.md' \\\n  .\n\n# Verify archive was created\nif [ ! -f \"nextdash-deployment.tar.gz\" ]; then\n  echo \"❌ Failed to create deployment archive\"\n  exit 1\nfi\n\necho \"✅ Deployment archive created ($(du -h nextdash-deployment.tar.gz | cut -f1))\"\n"
      - name: Upload to server
        run: |
          echo "⬆️ Uploading deployment archive..."

          # Upload with retry mechanism
          for i in {1..3}; do
            if scp -o ConnectTimeout=30 -P 65002 nextdash-deployment.tar.gz ${{ secrets.HOSTINGER_USER }}@${{ secrets.HOSTINGER_HOST }}:/tmp/; then
              echo "✅ Upload successful"
              break
            else
              echo "⚠️ Upload attempt $i failed, retrying..."
              sleep 10
            fi
          done
      - name: Deploy application
        run: "ssh -o ConnectTimeout=30 -o ServerAliveInterval=10 -p 65002 ${{ secrets.HOSTINGER_USER }}@${{ secrets.HOSTINGER_HOST }} << 'EOF'\n  set -e\n  \n  echo \"\U0001F680 Starting deployment...\"\n  \n  # Define paths\n  APP_DIR=\"/var/www/nextdash-b\"\n  BACKUP_DIR=\"/var/backups/nextdash-b\"\n  TEMP_DIR=\"/tmp/nextdash-deploy-$$\"\n  \n  # Create directories\n  sudo mkdir -p \"$APP_DIR\" \"$BACKUP_DIR\" \"$TEMP_DIR\"\n  \n  # Stop existing application gracefully\n  echo \"⏹️ Stopping existing application...\"\n  if [ -f \"$APP_DIR/docker-compose.hostinger.yml\" ]; then\n    cd \"$APP_DIR\"\n    sudo docker-compose -f docker-compose.hostinger.yml down --timeout 30 || echo \"⚠️ Graceful shutdown failed, forcing...\"\n    sudo docker-compose -f docker-compose.hostinger.yml down --timeout 5 --volumes || true\n  fi\n  \n  # Clean up any orphaned containers\n  sudo docker container prune -f || true\n  \n  # Backup current deployment\n  if [ -d \"$APP_DIR\" ] && [ \"$(ls -A $APP_DIR 2>/dev/null)\" ]; then\n    echo \"\U0001F4BE Creating backup...\"\n    backup_file=\"$BACKUP_DIR/backup-$(date +%Y%m%d-%H%M%S).tar.gz\"\n    sudo tar -czf \"$backup_file\" -C \"$APP_DIR\" . 2>/dev/null || echo \"⚠️ Backup creation failed\"\n    \n    # Keep only last 5 backups\n    sudo find \"$BACKUP_DIR\" -name \"backup-*.tar.gz\" -type f | sort | head -n -5 | sudo xargs rm -f || true\n  fi\n  \n  # Extract new deployment to temp directory first\n  echo \"\U0001F4E6 Extracting new deployment...\"\n  cd \"$TEMP_DIR\"\n  if ! tar -xzf /tmp/nextdash-deployment.tar.gz; then\n    echo \"❌ Failed to extract deployment archive\"\n    exit 1\n  fi\n  \n  # Atomic move to production directory\n  echo \"\U0001F504 Deploying to production directory...\"\n  sudo rm -rf \"$APP_DIR\"/*\n  sudo mv \"$TEMP_DIR\"/* \"$APP_DIR\"/ 2>/dev/null || true\n  sudo chown -R \"$USER:$USER\" \"$APP_DIR\"\n  \n  # Navigate to app directory\n  cd \"$APP_DIR\"\n  \n  # Verify required files exist\n  if [ ! -f \"docker-compose.hostinger.yml\" ]; then\n    echo \"❌ docker-compose.hostinger.yml not found\"\n    exit 1\n  fi\n  \n  # Create production environment file\n  echo \"\U0001F527 Creating production environment...\"\n  cat > .env << 'EOL'\n# Production Environment - Auto-generated by GitHub Actions\nNEXT_PUBLIC_APP_NAME=NextDash-B\nNEXT_PUBLIC_APP_URL=${{ secrets.NEXT_PUBLIC_APP_URL }}\nNODE_ENV=production\n\n# Database Configuration\nDB_HOST=${{ secrets.DB_HOST }}\nDB_PORT=3306\nDB_NAME=${{ secrets.DB_NAME }}\nDB_USER=${{ secrets.DB_USER }}\nDB_PASSWORD=${{ secrets.DB_PASSWORD }}\nDB_SSL=false\n\n# Authentication\nJWT_SECRET=${{ secrets.JWT_SECRET }}\nJWT_REFRESH_SECRET=${{ secrets.JWT_REFRESH_SECRET }}\nJWT_EXPIRES_IN=1h\nJWT_REFRESH_EXPIRES_IN=7d\n\n# Email Configuration\nSMTP_HOST=mail.smtp2go.com\nSMTP_PORT=2525\nSMTP_USER=${{ secrets.SMTP_USER }}\nSMTP_PASSWORD=${{ secrets.SMTP_PASSWORD }}\nFROM_EMAIL=${{ secrets.FROM_EMAIL }}\n\n# File Upload\nMAX_FILE_SIZE=5MB\nUPLOAD_DIR=./uploads\n\n# Security\nBCRYPT_ROUNDS=12\nRATE_LIMIT_WINDOW=15\nRATE_LIMIT_MAX=100\n\n# Development\nDEBUG=false\nLOG_LEVEL=info\n\n# Admin Users\nADMIN_EMAIL=${{ secrets.ADMIN_EMAIL }}\nADMIN_PASSWORD=${{ secrets.ADMIN_PASSWORD }}\nADMIN_FIRST_NAME=Admin\nADMIN_LAST_NAME=User\nADMIN2_EMAIL=${{ secrets.ADMIN2_EMAIL }}\nADMIN2_PASSWORD=${{ secrets.ADMIN2_PASSWORD }}\nADMIN2_FIRST_NAME=Derek\nADMIN2_LAST_NAME=Admin\nEOL\n\n  # Set secure permissions\n  chmod 600 .env\n  \n  # Pull latest images and build\n  echo \"\U0001F3D7️ Building application...\"\n  sudo docker-compose -f docker-compose.hostinger.yml pull || echo \"⚠️ Pull failed, continuing with build...\"\n  \n  if ! sudo docker-compose -f docker-compose.hostinger.yml build --no-cache; then\n    echo \"❌ Build failed\"\n    exit 1\n  fi\n\n  echo \"\U0001F680 Starting application...\"\n  if ! sudo docker-compose -f docker-compose.hostinger.yml up -d; then\n    echo \"❌ Failed to start application\"\n    sudo docker-compose -f docker-compose.hostinger.yml logs\n    exit 1\n  fi\n\n  # Wait for application to start with timeout\n  echo \"⏳ Waiting for application to start...\"\n  timeout=60\n  counter=0\n  while [ $counter -lt $timeout ]; do\n    if sudo docker-compose -f docker-compose.hostinger.yml ps | grep -q \"Up\"; then\n      echo \"✅ Container is running\"\n      break\n    fi\n    echo \"⏳ Waiting... ($counter/$timeout seconds)\"\n    sleep 5\n    counter=$((counter + 5))\n  done\n\n  # Additional wait for application initialization\n  sleep 30\n\n  # Run database setup with error handling\n  echo \"\U0001F5C4️ Setting up database...\"\n  if sudo docker-compose -f docker-compose.hostinger.yml exec -T nextdash-app node scripts/setup-env-users.js; then\n    echo \"✅ Database setup completed successfully\"\n  else\n    echo \"⚠️ Database setup completed with warnings - checking logs...\"\n    sudo docker-compose -f docker-compose.hostinger.yml logs nextdash-app | tail -20\n  fi\n\n  # Health check with retry\n  echo \"\U0001F3E5 Performing health check...\"\n  health_check_passed=false\n  for i in {1..12}; do\n    if curl -f -s --max-time 10 http://localhost:3000/api/health > /dev/null 2>&1; then\n      echo \"✅ Application health check passed\"\n      health_check_passed=true\n      break\n    fi\n    echo \"⏳ Health check attempt $i/12...\"\n    sleep 10\n  done\n\n  if [ \"$health_check_passed\" = false ]; then\n    echo \"⚠️ Health check failed - checking logs...\"\n    sudo docker-compose -f docker-compose.hostinger.yml logs --tail=50\n  fi\n\n  # Show final status\n  echo \"\U0001F4CA Final deployment status:\"\n  sudo docker-compose -f docker-compose.hostinger.yml ps\n\n  echo \"\U0001F389 Deployment completed!\"\n  echo \"\U0001F310 Application URL: ${{ secrets.NEXT_PUBLIC_APP_URL }}\"\n\n  # Cleanup\n  rm -rf \"$TEMP_DIR\"\n  rm -f /tmp/nextdash-deployment.tar.gz\nEOF\n"
      - name: Verify deployment
        run: "echo \"\U0001F50D Verifying deployment...\"\n\n# Test SSH connection\nif ssh -o ConnectTimeout=10 -p 65002 ${{ secrets.HOSTINGER_USER }}@${{ secrets.HOSTINGER_HOST }} \"echo 'Post-deployment SSH test successful'\"; then\n  echo \"✅ SSH connection verified\"\nelse\n  echo \"❌ SSH connection failed\"\n  exit 1\nfi\n\n# Test application URL if accessible\nif [ -n \"${{ secrets.NEXT_PUBLIC_APP_URL }}\" ]; then\n  echo \"\U0001F310 Testing application URL...\"\n  sleep 15\n  \n  # Try health check endpoint\n  if curl -f -s --max-time 30 \"${{ secrets.NEXT_PUBLIC_APP_URL }}/api/health\" > /dev/null; then\n    echo \"✅ Application is responding at ${{ secrets.NEXT_PUBLIC_APP_URL }}\"\n  else\n    echo \"⚠️ Application health endpoint not responding (may still be initializing)\"\n    \n    # Try main page as fallback\n    if curl -f -s --max-time 30 \"${{ secrets.NEXT_PUBLIC_APP_URL }}\" > /dev/null; then\n      echo \"✅ Application main page is accessible\"\n    else\n      echo \"⚠️ Application not responding yet\"\n    fi\n  fi\nfi\n"
      - name: Cleanup
        if: always()
        run: "echo \"\U0001F9F9 Cleaning up...\"\nrm -f ~/.ssh/id_rsa\nrm -f nextdash-deployment.tar.gz\necho \"✅ Cleanup completed\"\n"
      - name: Deployment summary
        if: always()
        run: "echo \"## \U0001F389 Deployment Summary\" >> $GITHUB_STEP_SUMMARY\necho \"✅ **Status**: ${{ job.status }}\" >> $GITHUB_STEP_SUMMARY\necho \"\U0001F680 **Branch**: ${{ github.ref_name }}\" >> $GITHUB_STEP_SUMMARY\necho \"\U0001F4DD **Commit**: \\`${{ github.sha }}\\`\" >> $GITHUB_STEP_SUMMARY\necho \"\U0001F464 **Triggered by**: ${{ github.actor }}\" >> $GITHUB_STEP_SUMMARY\necho \"\U0001F310 **URL**: ${{ secrets.NEXT_PUBLIC_APP_URL }}\" >> $GITHUB_STEP_SUMMARY\necho \"⏰ **Completed**: $(date -u '+%Y-%m-%d %H:%M:%S UTC')\" >> $GITHUB_STEP_SUMMARY\necho \"\" >> $GITHUB_STEP_SUMMARY\necho \"### \U0001F4CB Next Steps:\" >> $GITHUB_STEP_SUMMARY\necho \"1. ✅ Verify application is working at your domain\" >> $GITHUB_STEP_SUMMARY\necho \"2. \U0001F510 Test admin login functionality\" >> $GITHUB_STEP_SUMMARY\necho \"3. \U0001F4CA Monitor application logs if needed\" >> $GITHUB_STEP_SUMMARY\necho \"4. \U0001F50D Check database connectivity and data integrity\" >> $GITHUB_STEP_SUMMARY\n"
